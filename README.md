# Rootkit
Project 1: Linux Rootkit

ROLES OF PROJECT:

1. Brain Lee : Hide specific files and directories from showing up when a user does "ls" and similar commands (you have to come up with a protocol that allows attackers to change these)
	* You can hide a total of 5 files and directories combined.
	* Indicate the files you want to hide by setting the `fileNames` parameter along with the `insmod rootkit.ko` command
	* Hide the "src" directory & "main.c" file by including `fileNames="src","main.c"`

2. Marc Da Rita: Modify the /etc/passwd and /etc/shadow file to add a backdoor account while returning the original contents of the files (pre-attack) when a normal user requests to see the file

3. Carlos Lopez: Hides specific processes from the process table when a user does a "ps"

4. Brendan Foley: Give the ability to a malicious process to elevate its uid to 0 (root) upon demand (again this involves coming up with a protocol for doing that)


kbuild: "kbuild" is the build system used by the Linux kernel. Modules must use kbuild to stay compatible with changes in the build infrastructure and to pick up the right flags to "gcc."

	* obj-$(CONFIG_FOO) += foo.o ->> tells kbuild that there is one object in that directory, named foo.o. foo.o will be 
	built from foo.c or foo.S.
	* $(CONFIG_FOO) evaluates to either y (for built-in) or m (for module). If CONFIG_FOO is neither y nor m, then the 
	file will not be compiled nor linked.


Helpful Terminal Command (Info on commands found @ https://www.gnu.org/software/):

	* uname: used to know system information. Running these command on the VM, these are the respective output:
		* uname -s (kernal-name): Linux
    		* uname -v (kernal-version): #46~16.04.1-Ubuntu SMP Mon Dec 4 15:57:59 UTC 2017
    		* uname -o (operating system): GNU/Linux
	* ps: display information about a selection of the active process
		* (need more info on command)
	* make: determines which pieces of programs need to be recompiled
		* In order to run make command you must have a file named Makefile which tells ... how to compile and link a 
		program 
		* Makefiles:
			* makefile consist of "rules", formatted as such,
				* target(name of file generated by a program): prerequisites(input files used tocreate-target)
					recipe(actions that carry out when make is calle. Can be more then one command)
			* To substitute a variable’s value (variable reference), use,
				* $(foo)
				* ${foo}
			* Function Call Syntax, formatted as such,
				* $(function arguments)
				* shell function:
					* communicates with the world outside of make. The shell function perform command 
					expansion. This means that it takes as an argument a shell command and evaluates to 
					the output of the command. The commands run by calls to the shell function are run 
					when the function calls are expanded. Basicallly spawns new shell and runs commmand
		* make -C : Change to directory dir before reading the makefiles or doing anything else.
		

Important Linux File Structure:

    * ./proc – Kernel & Process Files
		* The /proc directory similar to the /dev directory because it doesn’t contain
		  standard files. It contains special files that represent system and process information.
    


Kernal module:
(source): {https://unix.stackexchange.com/questions/47330/what-exactly-are-linux-kernel-headers, 
https://unix.stackexchange.com/questions/27042/what-does-a-kernel-source-tree-contain-is-this-related-to-linux-kernel-headers,
https://www.kernel.org/doc/html/latest/kbuild/modules.html,
https://en.wikipedia.org/wiki/Loadable_kernel_module,
https://linux-kernel-labs.github.io/master/labs/kernel_modules.html,
http://tldp.org/LDP/lkmpg/2.6/html/lkmpg.html#AEN181
}

	* Loadable kernel module (LMK) is an object file that contains code to extend the running kernel, or so-called base kernel, of an operating system. LKMs are typically used to add support for new hardware (as device drivers) and/or filesystems, or for adding system calls. When the functionality provided by a LKM is no longer required, it can be unloaded in order to free memory and other resources.

	* The adventage of having LMK is that they stop the operating system from having to include all possible anticipated functionality already compiled directly into the base kernel. Much of this  would reside in memory without being used,wasting memory, and would require that users rebuild and reboot the base kernel every time they require new functionality.

	* Disadventage of having LMK is that there could be a fragmetation penalty. On the contrary, a base kernal is unpacked into real contiguous memory by its setup routines; thus, the base kernel code is never fragmented. So, because an LMK is "outside code", there's a possible of the code crashing.
        
	* In terms of security,  LMK are a convenient method of modifying the running kernel, this can be abused by attackers on a compromised system to prevent detection of their processes or files, allowing them to maintain control over the system. Many rootkits make use of LKMs in this way. Note that on most operating systems modules do not help privilege elevation in any way, as elevated privilege is required to load a LKM; they merely make it easier for the attacker to hide the break-in.
			
	* Linux allows disabling module loading via sysctl option /proc/sys/kernel/modules_disabled. An initramfs (needs more outside information) system may load specific modules needed for a machine at boot and then disable module loading. This makes the security very similar to a monolithic kernel. If an attacker can change the initramfs, they can change the kernel binary.



Steps to test Rootkit:
	
	make
	
	sudo insmod rootkit.ko
	
	sudo dmesg
		
	sudo rmmod rootkit.ko 
	
Steps to test hidden user in passwd & shadow files:


	make
		(Compile main)
	sudo insmod rootkit.ko
		(Inject rootkit into kernel)
	cat /etc/passwd
		(View passwd file and see rootkituser is not listed)
	sudo cat /etc/shadow
		(View shadow file and see rootkituser is not listed)
	su rootkituser
		(Log in to rootkituser, despite not being listed in the passwd nor shadow files)
	cse331!
		(Logs into rootkit user)
	


